<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0077)http://grupos.tecnico.ulisboa.pt/~meic-cnv.daemon/labs/labs-pin/labs-pin.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-15">
		<title>Computação em Nuvem e Virtualização - Cloud Computing &amp; Virtualization</title>
		
	<style>@media print {#ghostery-purple-box {display:none !important}}</style></head>
	<body background="./lab01_files/public05-06" bgcolor="#ffffff" id="textArea">
		<table width="100%">
			<tbody><tr>
				<td valign="middle" align="right" width="176"></td>
				<td align="center">
					<h1>CNV - Computação em Nuvem e Virtualização <br> Cloud Computing &amp; Virtualization  <br> 2016/2017
					</h1>
					<a href="http://fenix.ist.utl.pt/cursos/meic-a">MEIC-A</a><br>
					<a href="http://fenix.ist.utl.pt/cursos/meic-t">MEIC-T</a><br>
					<a href="http://fenix.ist.utl.pt/cursos/merc">METI</a><br>
				</td>
				<td valign="middle" align="right" width="146">
					<a href="http://www.dei.ist.utl.pt/" target="_blank"><img border="0" src="./lab01_files/logodei.gif" width="144"></a>
				</td>
			</tr>
		</tbody></table>
		<blockquote>
			<hr noshade="" size="4" color="#b1bbd6">
			<h2 align="center">
				Laboratory 1: Introduction to Pin - Intel Instrumentation Tool</h2>
			<hr>
			<h3>Overview</h3>
			<p align="justify"><a href="http://www.pintool.org/"><b>Pin</b></a> is a tool from Intel for the instrumentation of programs, supporting multiple operating systems (e.g., Windows, Linux, MacOS) on multiple architectures (e.g., IA-32 a.k.a. x86, IA-32 EM64T a.k.a. x86-64, IA-64 a.k.a. Itanium).</p>
			<p>Instrumentation is performed directly on binary code, once it is loaded on memory, therefore no access to source code is required. All executed code is generated by pin by dynamically translating original program code. Original application code is never executed, alternating between pin code and translated code.</p>
			<p align="justify">Pin operates by applying a <b>tool </b>on a running <b>application</b>. A tool is a user-developed dynamic library containing functions that perform program <b>instrumentation</b> and <b>analysis</b>.
			</p><p align="justify"><b>Instrumentation</b> is performed <b> once </b> by registered callback functions that are invoked as code elements of the application program are translated (e.g., individual instructions, basic clocks, routines, libraries).
			These callbacks can perform modifications to code elements by inserting/appending additional code (e.g., inject calls to analysis functions).</p>
			<p align="justify"><b>Analysis</b> is performed <b> every time </b> a piece of instrumented code is executed and analysis functions are invoked. Successive invocations of analysis code allows aggregation of results during program execution.
			</p>
			<p> Pin is invoked with the following syntax: <br>
			<br></p><center><b>pin [Pin Args] [-t <tool dll=""> [Tool Args]] -- <app exe=""> [App args]</app></tool></b></center>
			<p></p>
	<hr>
<center>
<img src="./lab01_files/pin-overview.jpg" width="700">
</center>
			<hr>
			<h3>Support Material and Documentation</h3>

			<p>Pin Tutorials, Papers and Documentation available: </p>

			<ul>
				<li>Pin Tutorial presented at CGO 2013 conference: &nbsp;(<a href="http://grupos.tecnico.ulisboa.pt/~meic-cnv.daemon/labs/labs-pin/docs/cgo2013.pdf">pdf</a>) </li>
				<li>Original Pin Tutorial from Intel, 2006: &nbsp;(<a href="http://grupos.tecnico.ulisboa.pt/~meic-cnv.daemon/labs/labs-pin/docs/pin-tutorial-intel-2006.pdf">pdf</a>) </li>

				<br>
				<li>Pin User Manual (v3.2): &nbsp;(<a href="https://software.intel.com/sites/landingpage/pintool/docs/81205/Pin/html/">html</a>) </li>

				<br>
				<li>Pin FAQ: &nbsp;(<a href="https://software.intel.com/en-us/articles/pintool-faq">html</a>) </li>
				<br>
				<li>Pin original paper at PLDI 2005 conference: &nbsp;(<a href="http://grupos.tecnico.ulisboa.pt/~meic-cnv.daemon/labs/labs-pin/docs/pin-paper-pldi05.pdf">pdf</a>) </li>
				
				
				<br>
				<li>Pin recepient of <b><i>Most Influential PLDI Paper Award</i></b> for 2015: &nbsp;(<a href="http://www.sigplan.org/Awards/PLDI/">html</a>) </li>
				<i>This paper introduced Pin, a dynamic binary instrumentation framework that enables the creation of dynamic program analysis tools. Pin uses dynamic compilation to instrument executables and dynamically-linked libraries while they are running, permitting the tool writer to study the behavior of an application at the instruction level without significant perturbation to application behavior. The PLDI 2005 paper is highly cited and the system it describes is in widespread use in academia and industry. Pin's ease of use and relative efficiency have made it the tool of choice for dynamic binary instrumentation.</i>				
				<br><br>
								
				<li>Papers about Pin or using Pin at conferences: &nbsp;(<a href="https://software.intel.com/en-us/articles/pintool-papers">html</a>)
</li>
			</ul>

			<hr noshade="" size="4" color="#b1bbd6">

				<h2><b><u>RNL Installation Setup</u></b></h2>

				<h4><u>Linux/GCC</u></h4>
				<ul>
						<li> 1. pin <b>executable</b> should be already in the command path </li>
						<li> E.g. of first invocation to check pin:&gt;
						<br>
						<b> &gt; pin -version </b></li>
						<br>
					<!--	<li> Then start one shell and change current directory to <b>/usr/lib/rnl-m2-avexe-pintools</b> to look for tools, and </li>
						<li> Start another shell and change current directory to <b>/usr/share/src/pintools/</b> to check their source code.</li>	 -->

						<li> <b>2. To setup the local environment for the lab, execute the following: (you can copy &amp; paste) </b><br></li>
						&gt; mkdir /tmp/cnv/  <br>
						&gt; mkdir /tmp/cnv/pin <br>
						&gt; cd /tmp/cnv/pin <br>
						&gt; cp -R /opt/pin/* <b>.</b>    <i>(do not forget the final dot)</i>
						<br>
						
						<br>
						<li> <b>3. Build the first pin tools from source code: </b><br></li>
						&gt; cd /tmp/cnv/pin/source/tools/ManualExamples/  <br>
						&gt; make <br>
						
						<br>
												
						<li> <b>4. For convenience, keep one shell open in each of the following folders, to execute instrumentation tools and check their source code: </b><br></li>
						&gt; /tmp/cnv/pin/source/tools/ManualExamples/  <br>
						&gt; /tmp/cnv/pin/source/tools/ManualExamples/obj-intel64  <br>	
						
						<br>
						
						<br> <i>(and later) </i><br>
						&gt; /tmp/cnv/pin/source/tools/SimpleExamples/  <br>
						&gt; /tmp/cnv/pin/source/tools/SimpleExamples/obj-intel64  <br>	
						



					</ul>

				<hr>
				<h3> Main Directories of Pin Installation </h3>
				<ul>
					<li><b>ia32/</b> and <b>intel64/</b>: pin binaries - executable files (bin) and libraries (lib).</li>
					<br>
					<li><b>source/include/</b>: files to #include in pin tool code.</li>
					<br>
					<br><li><b>source/tools/SimpleExamples/</b>: examples of tools.</li>
					<li><b>source/tools/ManualExamples/</b>: examples of tools.</li>
					<li><b>source/tools/MyPinTool/</b>: example of tool to extend.</li>
					<br>
					<li>Pin tools <b>binary files</b> should be under <b>obj-intel64</b> subfolder in each examples folder</li>

				</ul>

			<hr noshade="" size="4" color="#b1bbd6">

			<h2 align="center">Structure of a Pin Tool</h2>
			<p> A Pin tool file is normally divided in the following sections:
			</p>
			<ul>
			<li><b>Include declarations</b></li>

			<li><b>Global variables</b>: used to aggregate results.</li>

			<li><b>Command line switches, i.e., KNOBS</b>: used to pass arguments to pin tools (e.g., KnobOutputFile).</li>

			<li><b>Usage Function</b>: prints tool usage syntax.</li>

			<li><b>Analysis routines</b>: update global variables when executed in instrumented code.</li>

			<li><b>Instrumentation callbacks</b>: configure program instrumentation by inserting calls to analysis routines.</li>
			<br>
			<li><b>Main function:</b></li>
				<ul>
				<li> Initialize Pin.</li>
				<li> Check Knobs. </li>
				<li> Add/Install Intrumentation Functions. </li>
				<li> Start Instrumented program. </li>
				</ul>
			</ul>

			<hr noshade="" size="4" color="#b1bbd6">




			<h2 align="center">Tasks</h2>
			<p> For each of the following sections, analyse and test the following pin tools.</p>
			<ol>
				<li> check if there is help regarding pin tool usage: </li>
				pin -t &lt;tool-name&gt; -help
				<br><br>
				<li> Test the tool with a simple command </li>
				pin -t &lt;tool-name&gt; -- ls -la
				<br><br>
				<li> Check analysis result written to file </li>
				less &lt;tool-name&gt;.out

				<br><br>
				<li> Analyse source code and identify mains areas of tool </li>
				 - Analysis and instrumentation functions, and main.<br>
				(you can check API functions in documentation)
				<br><br>
				<li> Test the tool with added work or more complex applications</li>
				pin -t &lt;tool-name&gt; -- ls -lR    (for recursive directory) <br>
				pin -t &lt;tool-name&gt; -- vi (and write/load/save some text file, you can use others such as joe, pico, vim, etc.)<br>
				pin -t &lt;tool-name&gt; -- &lt;path to other applications, notice slowdown on start-up for large applications, e.g., emacs or with graphics&gt;<br>
				<br><br>


				<br>
			</ol>
<hr>
			<h3> <b>A. Analyzing Instructions </b></h3>
			<ol>
				<li> Simple Instruction Count </li>
			Tool: <b>inscount0.so </b>  Source: inscount0.cpp <i>(from ManualExamples)</i> <br>
			Check number of executed instructions of application program.<br><br>


			<li> Adress Trace of Executed Instructions <i>(from ManualExamples)</i> </li>
			Tool: <b>itrace.so </b>  Source: itrace.cpp <br>
			List addresses of executed instructions of application program.<br><br>


			<li> Adress Trace of Referenced Memory Positions <i>(from ManualExamples)</i> </li>
			Tool: <b>pinatrace.so</b>  Source: pinatrace.cpp <br>
			List addresses of accessed memory and type of operation (read, write). <br><br>

					
			<li> Analysis of Types of Executed Instructions <i>(from SimpleExamples)</i></li>
			<br>
			<b>Now switch to a different directoy with other tools: </b><br>
			&gt; cd /tmp/cnv/pin/source/tools/SimpleExamples/  <br>
			&gt; make 
			<br>
			<br> <b> Keep one shell in each of the following folders:</b><br>
			&gt; /tmp/cnv/pin/source/tools/SimpleExamples/  <br>
			&gt; /tmp/cnv/pin/source/tools/SimpleExamples/obj-intel64  <br>	
			<br>
			
			Tool: <b>opcodemix.so</b>  Source: opcodemix.cpp <br>
			List opcodes of executed instructions with number of executions and category summary<br>
			Look for special instructions such as INT, SYSENTER/SYSCALL, ...<br><br>


			<li> Analysis of Register Use <i>(from SimpleExamples)</i></li>
			Tool: <b>regmix.so</b>  Source: regmix.cpp <br>
			<br>
			</ol>
<hr>
			<h3> <b>B. Analyzing Basic Blocks </b></h3>
			<ol>
			<li> Efficient Instruction Count <i>(from ManualExamples)</i></li>
			<br><b><i>(switch to a different directoy)</i> </b><br>
			&gt; cd /tmp/cnv/pin/source/tools/ManualExamples/  <br>
			<br>

			Tool: <b>inscount1.so</b>  Source: inscount1.cpp <br>
			Counts all instructions of a basic block at once.<br><br>

			<li> Edge Count <i>(from SimpleExamples)</i></li>
			<br><b><i>(switch to a different directoy)</i> </b><br>
			&gt; cd /tmp/cnv/pin/source/tools/SimpleExamples/  <br>
			<br>
			Tool: <b>edgcnt.so</b>  Source: edgcnt.cpp  <br>
			Lists addresses of jump instructions, type of jump (direct, indirect), and number of times performed.<br><br>
			</ol>

			<hr>
			
			<h3> C. Analyzing Routines and Libraries </h3>
			<ol>
			<li> Routine Invocation Call <i>(from ManualExamples)</i></li>
			
			<br><b><i>(switch to a different directoy)</i> </b><br>
			&gt; cd /tmp/cnv/pin/source/tools/ManualExamples/  <br>
			<br>
			
			Tool: <b>proccount.so</b>  Source: proccount.cpp  <br>
			Counts number of times each routine is invocked and number of instructions in it.<br><br>
			
			<li> Identify Libraries Used by Program <i>(from ManualExamples)</i></li>
			Tool: <b>imageload.so</b>  Source: imageload.cpp  <br>
			Lists loading and unloading of dynamic libraries invoked by program.<br><br>
			</ol>
			<hr noshade="" size="4" color="#b1bbd6">

			

			<h2 align="center">Fast Creation of New Pin Tool File</h2>
			
			<h3><u>Linux/GCC</u></h3>
				<ol>
					<li> Clone the MyPinTool directory inside <i> /tmp/cnv/pin/source/tools/ </i></li>
					<li> e.g. tmp/cnv/pin/source/tools&gt; cp -R MyPinTool/ teste
					</li><li> &gt; cd teste </li>
					<li> &gt; make</li><br>
					<li><b> edit MyPinTool.cpp file inside <i>teste</i> and re-make </b>.</li>
				</ol>
		<hr noshade="" size="4" color="#b1bbd6">
			<h2 align="center">Homework / Challenges</h2>
			<h3> <u>Homework / Challenges: </u></h3>
			<ol>
			<li> <b>Check out other pin tools. <i>and</i> Experiment with tools knobbs. </b></li><br>
			<li> <b> Design new tool with combined functionality: <i>Core component of Basic Block Code Cache.</i> </b><br>
			e.g., count number of executions of basic blocks; keep information of most recently executed basic blocks (e.g., a round-robbin code cache of N blocks) and check, on each execution, if there would be a hit or miss in the cache (consider capacity of N), and finally aggregate results of efficiency.
			<br>
			<i><b>Suggestion:</b> base your code on inscount1.cpp and edgcnt.cpp copied as MyPinTool.cpp in new directory.</i>
			<br><br>
			</li><li><b> Design new tool with combined functionality: <i>Core component of Register Allocator for Basic Block Translation. </i></b><br>
			e.g., for each basic block, keep information of the registers used by the code in that block. This information allows to find out the registers more heavily used in each block, and can drive register allocation decisions, i.e., which target (i.e., native) register should we map each register used (in the original code) to.
			<br>
			<i><b>Suggestion:</b> base your code by checking regmix.cpp and inscount1.cpp and edgcnt.cpp.</i>
			<br><br>
			</li><li><b> Design new tool with combined functionality: <i>Identify Basic Blocks that invoke system-calls (core component for identification of blocks where OS emulation is needed).</i></b><br>
			e.g., detect and record information regarding the basic blocks that invoke system-calls. In a process VM, these blocks must be detected beforehand, and emulated without allowing the guest code access the host OS directly (that might not even be executing in the machine).
			<br>
			<i><b>Suggestion:</b> base your code by checking opcodemix.cpp and inscount1.cpp and edgcnt.cpp.</i>
			<br><br>
			</li></ol>


			<br><br>
<hr noshade="" size="4" color="#b1bbd6">



</blockquote>





</body></html>